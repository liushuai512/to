<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>原型</title>
</head>
<body>

</body>
</html>
<script>

    /*
     * 原型模式
     *    1.函数（类）定义之后天生只带一个属性prototype（原型），并且属性的值仍然是一个对象，这个对象上也天生自带一个属性constructor,另外一个是__proto__。其中constructor的值是这个类本身，而__proto__属性的值，永远都指向自己所属类的原型
     *    Human。prototype。constructor==Human
     *
     *    2.任何一个实例也都天生自带一个__proto__属性，而这个属性的值指向这个实例所属类的原型，这个类的原型Human。prototype相对于每个实例来说都是一个公共区域。那么这个原型上的方法和实例
     *      h1.__proto__==Human.prototype
     *      ps:任何一个引用数类型都自带__proto__属性，并且都指向自己所属类的原型
     *
     *
     *    3.Object 是所有引用数据类型的基类，这个类的原型上的方法所有的引用类型都可以调用
     *    调用原则：如果存在私有属性那么就使用私有，否则在通过__proto__属性向上一级原型去查找。
     *
     *    5.定义在类的原型上的函数方法中的this一般是实例
     *    h1.eat（）=》
     *
     *    6。批量设置共有属性，就是用一个对象去覆盖原有的原型，导致constructor丢失
     *
     *
     *
     *
     *
     *
     * */
//    function Human(name) {
//        this.name = name;
//        this.eat = function () {
//
//        }
//    }


    //    var h1=new Human('ni');
    //    var h2=new Human('ta');
    //    console.log(h1,h2);
    //    console.log(h1.eat==h2.eat)


    function Fn(){
        this.x = 10;
    }
    Fn.prototype.getX = function (){
        console.log(this.x + this.y);
    }
    Fn.prototype.y = 20;
    var f = new Fn();
    f.getX();
    Fn.prototype.getX();
    Fn.prototype.getX == f.__proto__.getX;
    console.log(f.constructor);
    console.log(f.constructor.constructor); // ?

</script>