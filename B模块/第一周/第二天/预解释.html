<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!--
变量提前声明 ==》预解释


没有报错=》说明声明过了，===》undefined


区别：使用var关键字声明过的，在代码执行之前（预解释）阶段的值是undefined，但是使用function关键字声明的函数，在代码执行之前（预解释）阶段的值就已经是函数了==》var之声明没有赋值，function及声明又赋值。var浏览器会默认赋值undefined。


1、变量提升阶段 只看等号左边，即使等号又是函数，那这个函数名也不回提前声明
   console.log(fx);
   var fn=function fx(){}
2、变量提前不理会条件 ===》在不同的浏览器里不绝对
   console.log(num);   //说明在条件内的num里声明了
   if（5=6）{ true/false
   var num=10；
   }
3、自执行函数的函数名不回被提前声明，自运行函数一般不写函数名
无论是赋值还是返回过程（return）,只要等号右面或者return后是函数的执行，那么要先执行函数，然后把函数执行的结果在进行操作

4、当函数和变量重名，那么在变量提声阶段一最后一个函数为准，当代码执行到变量赋值的哪一行，以变量的值为准

5、return下面的代码虽然不被执行，但是在变量提升阶段是可以执行的
-->


<!--
1 预解释不理会等号右面的
2 预解释不理会条件
3 自运行函数不会被预解释
4 函数和变量重名
5 return下面的函数和变量是可以被预解释的


形参相当于生命在函数体（内）的私有变量
全局变量：相对于私有变量而言全局变量是公共的
形参和私有变量重名，声明私有变量的var关键字就可以忽略，但是赋值操作任然可以。
-->
<script>
//    function mul(){
//        //console.log(a)
//        //var a
//        a=1800
//        console.log(a)
//    }
//    mul();
//    console.log(a)
//
//
//    var b=999
//    console.log(window.b)

//    console.log(ary);
//    var ary=[1,2];
//    function fn(ary){
//        console.log(ary);
//        ary.push(3);
//        ary=ary.slice(0);
//
//        ary.push(4);
//        console.log(ary);
//    }
//    fn(ary);
//    console.log(ary);




//var ary=[1,2,3]
//ary=ary.reverse() //[3, 2, 1]
//ary===ary.reverse() 他比较的是地址
//true

    console.log(total);
    function sum(num1,num2/*,total*/){
        console.log(total);
        /*var*/ total=num1+num2;
        console.log(total);
    }
    var total=0;
    sum(1,2);
     console.log(total);

</script>
</body>
</html>